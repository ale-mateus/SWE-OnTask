"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoClient = exports.ServerApiVersion = void 0;
<<<<<<< HEAD
const util_1 = require("util");
=======
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
const bson_1 = require("./bson");
const change_stream_1 = require("./change_stream");
const connection_string_1 = require("./connection_string");
const db_1 = require("./db");
const error_1 = require("./error");
<<<<<<< HEAD
const mongo_logger_1 = require("./mongo_logger");
const mongo_types_1 = require("./mongo_types");
const read_preference_1 = require("./read_preference");
const server_selection_1 = require("./sdam/server_selection");
const topology_1 = require("./sdam/topology");
const sessions_1 = require("./sessions");
=======
const mongo_types_1 = require("./mongo_types");
const connect_1 = require("./operations/connect");
const promise_provider_1 = require("./promise_provider");
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
const utils_1 = require("./utils");
/** @public */
exports.ServerApiVersion = Object.freeze({
    v1: '1'
});
/** @internal */
const kOptions = Symbol('options');
/**
 * The **MongoClient** class is a class that allows for making Connections to MongoDB.
 * @public
 *
 * @remarks
 * The programmatically provided options take precedent over the URI options.
 *
 * @example
 * ```js
 * // Connect using a MongoClient instance
 * const MongoClient = require('mongodb').MongoClient;
 * const test = require('assert');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * const mongoClient = new MongoClient(url);
 * mongoClient.connect(function(err, client) {
 *   const db = client.db(dbName);
 *   client.close();
 * });
 * ```
 *
 * @example
 * ```js
 * // Connect using the MongoClient.connect static method
 * const MongoClient = require('mongodb').MongoClient;
 * const test = require('assert');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) {
 *   const db = client.db(dbName);
 *   client.close();
 * });
 * ```
 */
class MongoClient extends mongo_types_1.TypedEventEmitter {
    constructor(url, options) {
        super();
        this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options);
<<<<<<< HEAD
        this.mongoLogger = new mongo_logger_1.MongoLogger(this[kOptions].mongoLoggerOptions);
=======
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const client = this;
        // The internal state
        this.s = {
            url,
            sessions: new Set(),
            bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),
            namespace: (0, utils_1.ns)('admin'),
<<<<<<< HEAD
            hasBeenClosed: false,
            sessionPool: new sessions_1.ServerSessionPool(this),
            activeSessions: new Set(),
=======
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
            get options() {
                return client[kOptions];
            },
            get readConcern() {
                return client[kOptions].readConcern;
            },
            get writeConcern() {
                return client[kOptions].writeConcern;
            },
            get readPreference() {
                return client[kOptions].readPreference;
            },
            get logger() {
                return client[kOptions].logger;
<<<<<<< HEAD
            },
            get isMongoClient() {
                return true;
            }
        };
    }
    /** @see MongoOptions */
=======
            }
        };
    }
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
    get options() {
        return Object.freeze({ ...this[kOptions] });
    }
    get serverApi() {
        return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });
    }
    /**
     * Intended for APM use only
     * @internal
     */
    get monitorCommands() {
        return this[kOptions].monitorCommands;
    }
    set monitorCommands(value) {
        this[kOptions].monitorCommands = value;
    }
    get autoEncrypter() {
        return this[kOptions].autoEncrypter;
    }
    get readConcern() {
        return this.s.readConcern;
    }
    get writeConcern() {
        return this.s.writeConcern;
    }
    get readPreference() {
        return this.s.readPreference;
    }
    get bsonOptions() {
        return this.s.bsonOptions;
    }
<<<<<<< HEAD
    /** @deprecated The Legacy Logger is deprecated and will be removed in the next major version. */
    get logger() {
        return this.s.logger;
    }
    connect(callback) {
        if (callback && typeof callback !== 'function') {
            throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');
        }
        return (0, utils_1.maybeCallback)(async () => {
            if (this.connectionLock) {
                return this.connectionLock;
            }
            try {
                this.connectionLock = this._connect();
                await this.connectionLock;
                return this;
            }
            finally {
                this.connectionLock = undefined;
            }
        }, callback);
    }
    async _connect() {
        if (this.topology && this.topology.isConnected()) {
            return this;
        }
        const options = this[kOptions];
        if (typeof options.srvHost === 'string') {
            const hosts = await (0, connection_string_1.resolveSRVRecord)(options);
            for (const [index, host] of hosts.entries()) {
                options.hosts[index] = host;
            }
        }
        const topology = new topology_1.Topology(options.hosts, options);
        // Events can be emitted before initialization is complete so we have to
        // save the reference to the topology on the client ASAP if the event handlers need to access it
        this.topology = topology;
        topology.client = this;
        topology.once(topology_1.Topology.OPEN, () => this.emit('open', this));
        for (const event of constants_1.MONGO_CLIENT_EVENTS) {
            topology.on(event, (...args) => this.emit(event, ...args));
        }
        const topologyConnect = async () => {
            try {
                await (0, util_1.promisify)(callback => topology.connect(options, callback))();
            }
            catch (error) {
                topology.close({ force: true });
                throw error;
            }
        };
        if (this.autoEncrypter) {
            const initAutoEncrypter = (0, util_1.promisify)(callback => { var _a; return (_a = this.autoEncrypter) === null || _a === void 0 ? void 0 : _a.init(callback); });
            await initAutoEncrypter();
            await topologyConnect();
            await options.encrypter.connectInternalClient();
        }
        else {
            await topologyConnect();
        }
        return this;
    }
    close(forceOrCallback, callback) {
        // There's no way to set hasBeenClosed back to false
        Object.defineProperty(this.s, 'hasBeenClosed', {
            value: true,
            enumerable: true,
            configurable: false,
            writable: false
        });
=======
    get logger() {
        return this.s.logger;
    }
    connect(callback) {
        if (callback && typeof callback !== 'function') {
            throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');
        }
        return (0, utils_1.maybePromise)(callback, cb => {
            (0, connect_1.connect)(this, this[kOptions], err => {
                if (err)
                    return cb(err);
                cb(undefined, this);
            });
        });
    }
    close(forceOrCallback, callback) {
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
        if (typeof forceOrCallback === 'function') {
            callback = forceOrCallback;
        }
        const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;
<<<<<<< HEAD
        return (0, utils_1.maybeCallback)(async () => {
            const activeSessionEnds = Array.from(this.s.activeSessions, session => session.endSession());
            this.s.activeSessions.clear();
            await Promise.all(activeSessionEnds);
            if (this.topology == null) {
                return;
            }
            // If we would attempt to select a server and get nothing back we short circuit
            // to avoid the server selection timeout.
            const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
            const topologyDescription = this.topology.description;
            const serverDescriptions = Array.from(topologyDescription.servers.values());
            const servers = selector(topologyDescription, serverDescriptions);
            if (servers.length !== 0) {
                const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
                if (endSessions.length !== 0) {
                    await this.db('admin')
                        .command({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true })
                        .catch(() => null); // outcome does not matter
                }
=======
        return (0, utils_1.maybePromise)(callback, callback => {
            if (this.topology == null) {
                return callback();
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
            }
            // clear out references to old topology
            const topology = this.topology;
            this.topology = undefined;
<<<<<<< HEAD
            await new Promise((resolve, reject) => {
                topology.close({ force }, error => {
                    if (error)
                        return reject(error);
                    const { encrypter } = this[kOptions];
                    if (encrypter) {
                        return encrypter.close(this, force, error => {
                            if (error)
                                return reject(error);
                            resolve();
                        });
                    }
                    resolve();
                });
            });
        }, callback);
=======
            topology.close({ force }, error => {
                if (error)
                    return callback(error);
                const { encrypter } = this[kOptions];
                if (encrypter) {
                    return encrypter.close(this, force, error => {
                        callback(error);
                    });
                }
                callback();
            });
        });
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
    }
    /**
     * Create a new Db instance sharing the current socket connections.
     *
     * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.
     * @param options - Optional settings for Db construction
     */
    db(dbName, options) {
        options = options !== null && options !== void 0 ? options : {};
        // Default to db from connection string if not provided
        if (!dbName) {
            dbName = this.options.dbName;
        }
        // Copy the options and add out internal override of the not shared flag
        const finalOptions = Object.assign({}, this[kOptions], options);
        // Return the db object
        const db = new db_1.Db(this, dbName, finalOptions);
        // Return the database
        return db;
    }
    static connect(url, options, callback) {
<<<<<<< HEAD
        callback =
            typeof callback === 'function'
                ? callback
                : typeof options === 'function'
                    ? options
                    : undefined;
        return (0, utils_1.maybeCallback)(async () => {
            options = typeof options !== 'function' ? options : undefined;
            const client = new this(url, options);
            return client.connect();
        }, callback);
=======
        if (typeof options === 'function')
            (callback = options), (options = {});
        options = options !== null && options !== void 0 ? options : {};
        try {
            // Create client
            const mongoClient = new MongoClient(url, options);
            // Execute the connect method
            if (callback) {
                return mongoClient.connect(callback);
            }
            else {
                return mongoClient.connect();
            }
        }
        catch (error) {
            if (callback)
                return callback(error);
            else
                return promise_provider_1.PromiseProvider.get().reject(error);
        }
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
    }
    startSession(options) {
        options = Object.assign({ explicit: true }, options);
        if (!this.topology) {
            throw new error_1.MongoNotConnectedError('MongoClient must be connected to start a session');
        }
        return this.topology.startSession(options, this.s.options);
    }
    withSession(optionsOrOperation, callback) {
        const options = {
            // Always define an owner
            owner: Symbol(),
            // If it's an object inherit the options
            ...(typeof optionsOrOperation === 'object' ? optionsOrOperation : {})
        };
        const withSessionCallback = typeof optionsOrOperation === 'function' ? optionsOrOperation : callback;
        if (withSessionCallback == null) {
            throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');
        }
        const session = this.startSession(options);
<<<<<<< HEAD
        return (0, utils_1.maybeCallback)(async () => {
            try {
                await withSessionCallback(session);
            }
            finally {
                try {
                    await session.endSession();
                }
                catch {
                    // We are not concerned with errors from endSession()
                }
            }
        }, null);
=======
        const Promise = promise_provider_1.PromiseProvider.get();
        return Promise.resolve()
            .then(() => withSessionCallback(session))
            .then(() => {
            // Do not return the result of callback
        })
            .finally(() => session.endSession());
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
    }
    /**
     * Create a new Change Stream, watching for new changes (insertions, updates,
     * replacements, deletions, and invalidations) in this cluster. Will ignore all
     * changes to system collections, as well as the local, admin, and config databases.
     *
<<<<<<< HEAD
     * @remarks
     * watch() accepts two generic arguments for distinct use cases:
     * - The first is to provide the schema that may be defined for all the data within the current cluster
     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
     *
=======
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
     * @param options - Optional settings for the command
     */
    watch(pipeline = [], options = {}) {
        // Allow optionally not specifying a pipeline
        if (!Array.isArray(pipeline)) {
            options = pipeline;
            pipeline = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
<<<<<<< HEAD
    /**
     * Return the mongo client logger
     * @deprecated The Legacy Logger is deprecated and will be removed in the next major version.
     */
=======
    /** Return the mongo client logger */
>>>>>>> 74cef31c53446458318958f397d10b24a7430297
    getLogger() {
        return this.s.logger;
    }
}
exports.MongoClient = MongoClient;
//# sourceMappingURL=mongo_client.js.map